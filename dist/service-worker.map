{"version":3,"sources":["node_modules/idb/lib/idb.js","service-worker.js"],"names":["dbReady","self","addEventListener","waitUntil","caches","open","cacheName","then","addAssets","cache","addAll","assets","catch","log","error","addRoot","fetch","response","ok","TypeError","put","Promise","all","e","dbPromise","idb","upgradeDB","oldVersion","createObjectStore","keyPath","createIndex","cacheRequest","event","request","URL","url","indexOf","Request","checkURL","port","parts","pathname","split","id","searchParams","get","length","hostname","handleAJAXEvent","method","fetchResponse","json","handleReviewsEvent","respondWith","db","transaction","objectStore","index","getAll","data","itx","store","forEach","review","finalResponse","mapResponse","map","Response","JSON","stringify","status","handleRestaurantEvent","handleNonAJAXEvent","match","clone"],"mappings":"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","file":"service-worker.map","sourceRoot":"..","sourcesContent":["'use strict';\n\n(function() {\n  function toArray(arr) {\n    return Array.prototype.slice.call(arr);\n  }\n\n  function promisifyRequest(request) {\n    return new Promise(function(resolve, reject) {\n      request.onsuccess = function() {\n        resolve(request.result);\n      };\n\n      request.onerror = function() {\n        reject(request.error);\n      };\n    });\n  }\n\n  function promisifyRequestCall(obj, method, args) {\n    var request;\n    var p = new Promise(function(resolve, reject) {\n      request = obj[method].apply(obj, args);\n      promisifyRequest(request).then(resolve, reject);\n    });\n\n    p.request = request;\n    return p;\n  }\n\n  function promisifyCursorRequestCall(obj, method, args) {\n    var p = promisifyRequestCall(obj, method, args);\n    return p.then(function(value) {\n      if (!value) return;\n      return new Cursor(value, p.request);\n    });\n  }\n\n  function proxyProperties(ProxyClass, targetProp, properties) {\n    properties.forEach(function(prop) {\n      Object.defineProperty(ProxyClass.prototype, prop, {\n        get: function() {\n          return this[targetProp][prop];\n        },\n        set: function(val) {\n          this[targetProp][prop] = val;\n        }\n      });\n    });\n  }\n\n  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return this[targetProp][prop].apply(this[targetProp], arguments);\n      };\n    });\n  }\n\n  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function Index(index) {\n    this._index = index;\n  }\n\n  proxyProperties(Index, '_index', [\n    'name',\n    'keyPath',\n    'multiEntry',\n    'unique'\n  ]);\n\n  proxyRequestMethods(Index, '_index', IDBIndex, [\n    'get',\n    'getKey',\n    'getAll',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(Index, '_index', IDBIndex, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  function Cursor(cursor, request) {\n    this._cursor = cursor;\n    this._request = request;\n  }\n\n  proxyProperties(Cursor, '_cursor', [\n    'direction',\n    'key',\n    'primaryKey',\n    'value'\n  ]);\n\n  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [\n    'update',\n    'delete'\n  ]);\n\n  // proxy 'next' methods\n  ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n    if (!(methodName in IDBCursor.prototype)) return;\n    Cursor.prototype[methodName] = function() {\n      var cursor = this;\n      var args = arguments;\n      return Promise.resolve().then(function() {\n        cursor._cursor[methodName].apply(cursor._cursor, args);\n        return promisifyRequest(cursor._request).then(function(value) {\n          if (!value) return;\n          return new Cursor(value, cursor._request);\n        });\n      });\n    };\n  });\n\n  function ObjectStore(store) {\n    this._store = store;\n  }\n\n  ObjectStore.prototype.createIndex = function() {\n    return new Index(this._store.createIndex.apply(this._store, arguments));\n  };\n\n  ObjectStore.prototype.index = function() {\n    return new Index(this._store.index.apply(this._store, arguments));\n  };\n\n  proxyProperties(ObjectStore, '_store', [\n    'name',\n    'keyPath',\n    'indexNames',\n    'autoIncrement'\n  ]);\n\n  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'put',\n    'add',\n    'delete',\n    'clear',\n    'get',\n    'getAll',\n    'getKey',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  proxyMethods(ObjectStore, '_store', IDBObjectStore, [\n    'deleteIndex'\n  ]);\n\n  function Transaction(idbTransaction) {\n    this._tx = idbTransaction;\n    this.complete = new Promise(function(resolve, reject) {\n      idbTransaction.oncomplete = function() {\n        resolve();\n      };\n      idbTransaction.onerror = function() {\n        reject(idbTransaction.error);\n      };\n      idbTransaction.onabort = function() {\n        reject(idbTransaction.error);\n      };\n    });\n  }\n\n  Transaction.prototype.objectStore = function() {\n    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n  };\n\n  proxyProperties(Transaction, '_tx', [\n    'objectStoreNames',\n    'mode'\n  ]);\n\n  proxyMethods(Transaction, '_tx', IDBTransaction, [\n    'abort'\n  ]);\n\n  function UpgradeDB(db, oldVersion, transaction) {\n    this._db = db;\n    this.oldVersion = oldVersion;\n    this.transaction = new Transaction(transaction);\n  }\n\n  UpgradeDB.prototype.createObjectStore = function() {\n    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n  };\n\n  proxyProperties(UpgradeDB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(UpgradeDB, '_db', IDBDatabase, [\n    'deleteObjectStore',\n    'close'\n  ]);\n\n  function DB(db) {\n    this._db = db;\n  }\n\n  DB.prototype.transaction = function() {\n    return new Transaction(this._db.transaction.apply(this._db, arguments));\n  };\n\n  proxyProperties(DB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(DB, '_db', IDBDatabase, [\n    'close'\n  ]);\n\n  // Add cursor iterators\n  // TODO: remove this once browsers do the right thing with promises\n  ['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n    [ObjectStore, Index].forEach(function(Constructor) {\n      // Don't create iterateKeyCursor if openKeyCursor doesn't exist.\n      if (!(funcName in Constructor.prototype)) return;\n\n      Constructor.prototype[funcName.replace('open', 'iterate')] = function() {\n        var args = toArray(arguments);\n        var callback = args[args.length - 1];\n        var nativeObject = this._store || this._index;\n        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n        request.onsuccess = function() {\n          callback(request.result);\n        };\n      };\n    });\n  });\n\n  // polyfill getAll\n  [Index, ObjectStore].forEach(function(Constructor) {\n    if (Constructor.prototype.getAll) return;\n    Constructor.prototype.getAll = function(query, count) {\n      var instance = this;\n      var items = [];\n\n      return new Promise(function(resolve) {\n        instance.iterateCursor(query, function(cursor) {\n          if (!cursor) {\n            resolve(items);\n            return;\n          }\n          items.push(cursor.value);\n\n          if (count !== undefined && items.length == count) {\n            resolve(items);\n            return;\n          }\n          cursor.continue();\n        });\n      });\n    };\n  });\n\n  var exp = {\n    open: function(name, version, upgradeCallback) {\n      var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n      var request = p.request;\n\n      if (request) {\n        request.onupgradeneeded = function(event) {\n          if (upgradeCallback) {\n            upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n          }\n        };\n      }\n\n      return p.then(function(db) {\n        return new DB(db);\n      });\n    },\n    delete: function(name) {\n      return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n    }\n  };\n\n  if (typeof module !== 'undefined') {\n    module.exports = exp;\n    module.exports.default = module.exports;\n  }\n  else {\n    self.idb = exp;\n  }\n}());\n","import idb from \"idb\";\r\n\r\nlet dbReady = false;\r\n\r\nself.addEventListener(\"install\", event => {\r\n  event.waitUntil(\r\n    caches.open(cacheName).then(cache => {\r\n      const addAssets = cache.addAll(assets).catch(error => {\r\n        console.log(error);\r\n      });\r\n      const addRoot = fetch(\"/index.html\").then(response => {\r\n        if (!response.ok) {\r\n          throw new TypeError(\"bad response status\");\r\n        }\r\n        return cache.put(\"/\", response);\r\n      });\r\n\r\n      return Promise.all([addAssets, addRoot]).catch(e => {\r\n        console.log(e);\r\n      });\r\n    })\r\n  );\r\n});\r\n\r\nconst dbPromise = idb.open(\"fm-udacity-restaurant\", 3, upgradeDB => {\r\n  switch (upgradeDB.oldVersion) {\r\n    case 0:\r\n      upgradeDB.createObjectStore(\"restaurants\", {keyPath: \"id\"});\r\n    case 1:\r\n      {\r\n        const reviewsStore = upgradeDB.createObjectStore(\"reviews\", {keyPath: \"id\"});\r\n        reviewsStore.createIndex(\"restaurant_id\", \"restaurant_id\");\r\n      }\r\n    case 2:\r\n      upgradeDB.createObjectStore(\"pending\", {\r\n        keyPath: \"id\",\r\n        autoIncrement: true\r\n      });\r\n  }\r\n});\r\n\r\nself.addEventListener(\"fetch\", event => {\r\n  let cacheRequest = event.request;\r\n  let cacheUrlObj = new URL(event.request.url);\r\n  if (event.request.url.indexOf(\"restaurant.html\") > -1) {\r\n    const cacheURL = \"restaurant.html\";\r\n    cacheRequest = new Request(cacheURL);\r\n  }\r\n\r\n  // Requests going to the API get handled separately from those going to other\r\n  // destinations\r\n  const checkURL = new URL(event.request.url);\r\n  if (checkURL.port === \"1337\") {\r\n    const parts = checkURL\r\n      .pathname\r\n      .split(\"/\");\r\n    let id = checkURL\r\n      .searchParams\r\n      .get(\"restaurant_id\") - 0;\r\n    if (!id) {\r\n      if (checkURL.pathname.indexOf(\"restaurants\")) {\r\n        id = parts[parts.length - 1] === \"restaurants\"\r\n          ? \"-1\"\r\n          : parts[parts.length - 1];\r\n      } else {\r\n        id = checkURL\r\n          .searchParams\r\n          .get(\"restaurant_id\");\r\n      }\r\n    }\r\n    handleAJAXEvent(event, id);\r\n  } else {\r\n    if (checkURL.hostname.indexOf(\"mapbox.com\") > -1) {\r\n      return;\r\n    }\r\n    handleNonAJAXEvent(event, cacheRequest);\r\n  }\r\n});\r\n\r\nconst handleAJAXEvent = (event, id) => {\r\n  // Only use caching for GET events\r\n  if (event.request.method !== \"GET\") {\r\n    return fetch(event.request)\r\n      .then(fetchResponse => fetchResponse.json())\r\n      .then(json => {\r\n        return json\r\n      });\r\n  }\r\n\r\n  // Split these request for handling restaurants vs reviews\r\n  if (event.request.url.indexOf(\"reviews\") > -1) {\r\n    handleReviewsEvent(event, id);\r\n  } else {\r\n    handleRestaurantEvent(event, id);\r\n  }\r\n}\r\n\r\nconst handleReviewsEvent = (event, id) => {\r\n  event.respondWith(dbPromise.then(db => {\r\n    return db\r\n      .transaction(\"reviews\")\r\n      .objectStore(\"reviews\")\r\n      .index(\"restaurant_id\")\r\n      .getAll(id);\r\n  }).then(data => {\r\n    return (data.length && data) || fetch(event.request)\r\n      .then(fetchResponse => fetchResponse.json())\r\n      .then(data => {\r\n        return dbPromise.then(idb => {\r\n          const itx = idb.transaction(\"reviews\", \"readwrite\");\r\n          const store = itx.objectStore(\"reviews\");\r\n          data.forEach(review => {\r\n            store.put({id: review.id, \"restaurant_id\": review[\"restaurant_id\"], data: review});\r\n          })\r\n          return data;\r\n        })\r\n      })\r\n  }).then(finalResponse => {\r\n    if (finalResponse[0].data) {\r\n      // Need to transform the data to the proper format\r\n      const mapResponse = finalResponse.map(review => review.data);\r\n      return new Response(JSON.stringify(mapResponse));\r\n    }\r\n    return new Response(JSON.stringify(finalResponse));\r\n  }).catch(error => {\r\n    return new Response(\"Error fetching data\", {status: 500})\r\n  }))\r\n}\r\n\r\nconst handleRestaurantEvent = (event, id) => {\r\n  // Check the IndexedDB to see if the JSON for the API has already been stored\r\n  // there. If so, return that. If not, request it from the API, store it, and\r\n  // then return it back.\r\n  event.respondWith(dbPromise.then(db => {\r\n    return db\r\n      .transaction(\"restaurants\")\r\n      .objectStore(\"restaurants\")\r\n      .get(id);\r\n  }).then(data => {\r\n    return (data && data.data) || fetch(event.request)\r\n      .then(fetchResponse => fetchResponse.json())\r\n      .then(json => {\r\n        return dbPromise.then(db => {\r\n          const tx = db.transaction(\"restaurants\", \"readwrite\");\r\n          const store = tx.objectStore(\"restaurants\");\r\n          store.put({id: id, data: json});\r\n          return json;\r\n        });\r\n      });\r\n  }).then(finalResponse => {\r\n    return new Response(JSON.stringify(finalResponse));\r\n  }).catch(error => {\r\n    return new Response(\"Error fetching data\", {status: 500});\r\n  }));\r\n};\r\n\r\nconst handleNonAJAXEvent = (event, cacheRequest) => {\r\n  // Check if the HTML request has previously been cached. If so, return the\r\n  // response from the cache. If not, fetch the request, cache it, and then return\r\n  // it.\r\n  event.respondWith(caches.match(cacheRequest).then(response => {\r\n    return (response || fetch(event.request).then(fetchResponse => {\r\n      return caches\r\n        .open(cacheName)\r\n        .then(cache => {\r\n          if (fetchResponse.url.indexOf(\"browser-sync\") === -1) {\r\n            cache.put(event.request, fetchResponse.clone());\r\n          }\r\n          return fetchResponse;\r\n        });\r\n    }).catch(error => {\r\n      return new Response(\"Application is not connected to the internet\", {\r\n        status: 404,\r\n        statusText: \"Application is not connected to the internet\"\r\n      });\r\n    }));\r\n  }));\r\n};\r\n"]}